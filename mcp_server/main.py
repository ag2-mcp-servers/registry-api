# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T14:48:48+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity
from fastapi import Query

from models import (
    Api,
    ApiDeployment,
    ApiSpec,
    ApiVersion,
    Artifact,
    ListApiDeploymentRevisionsResponse,
    ListApiDeploymentsResponse,
    ListApiSpecRevisionsResponse,
    ListApiSpecsResponse,
    ListApisResponse,
    ListApiVersionsResponse,
    ListArtifactsResponse,
    RollbackApiDeploymentRequest,
    RollbackApiSpecRequest,
    Status,
    TagApiDeploymentRevisionRequest,
    TagApiSpecRevisionRequest,
)

app = MCPProxy(
    description='The Registry service allows teams to manage descriptions of APIs.',
    title='Registry API',
    version='0.0.1',
    servers=[
        {'url': 'http://apigee.local'},
        {'url': 'https://apigeeregistry.googleapis.com'},
    ],
)


@app.get(
    '/v1/projects/{project}/locations/{location}/apis',
    description=""" ListApis returns matching APIs. """,
    tags=['api_management', 'artifact_management'],
)
def registry__list_apis(
    project: str,
    location: str = ...,
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    filter: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/projects/{project}/locations/{location}/apis',
    description=""" CreateApi creates a specified API. """,
    tags=[
        'api_management',
        'api_deployment_management',
        'api_version_control',
        'api_specification_handling',
        'artifact_management',
        'artifact_registry_management',
    ],
)
def registry__create_api(
    project: str,
    location: str = ...,
    api_id: Optional[str] = Query(None, alias='apiId'),
    body: Api = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/projects/{project}/locations/{location}/apis/{api}',
    description=""" DeleteApi removes a specified API and all of the resources that it
 owns. """,
    tags=[
        'api_management',
        'api_deployment_management',
        'api_version_control',
        'api_specification_handling',
        'artifact_management',
        'artifact_registry_management',
    ],
)
def registry__delete_api(
    project: str, location: str = ..., api: str = ..., force: Optional[bool] = None
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/projects/{project}/locations/{location}/apis/{api}',
    description=""" GetApi returns a specified API. """,
    tags=[
        'api_management',
        'api_deployment_management',
        'api_version_control',
        'api_specification_handling',
        'artifact_management',
        'artifact_registry_management',
    ],
)
def registry__get_api(project: str, location: str = ..., api: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/projects/{project}/locations/{location}/apis/{api}',
    description=""" UpdateApi can be used to modify a specified API. """,
    tags=['api_deployment_management'],
)
def registry__update_api(
    project: str,
    location: str = ...,
    api: str = ...,
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    allow_missing: Optional[bool] = Query(None, alias='allowMissing'),
    body: Api = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/projects/{project}/locations/{location}/apis/{api}/deployments',
    description=""" ListApiDeployments returns matching deployments. """,
    tags=['api_management', 'artifact_management'],
)
def registry__list_api_deployments(
    project: str,
    location: str = ...,
    api: str = ...,
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    filter: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/projects/{project}/locations/{location}/apis/{api}/deployments',
    description=""" CreateApiDeployment creates a specified deployment. """,
    tags=['api_deployment_management'],
)
def registry__create_api_deployment(
    project: str,
    location: str = ...,
    api: str = ...,
    api_deployment_id: Optional[str] = Query(None, alias='apiDeploymentId'),
    body: ApiDeployment = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}',
    description=""" DeleteApiDeployment removes a specified deployment, all revisions, and all
 child resources (e.g. artifacts). """,
    tags=['api_deployment_management', 'api_management'],
)
def registry__delete_api_deployment(
    project: str,
    location: str = ...,
    api: str = ...,
    deployment: str = ...,
    force: Optional[bool] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}',
    description=""" GetApiDeployment returns a specified deployment. """,
    tags=['api_deployment_management'],
)
def registry__get_api_deployment(
    project: str, location: str = ..., api: str = ..., deployment: str = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}',
    description=""" UpdateApiDeployment can be used to modify a specified deployment. """,
    tags=['api_deployment_management'],
)
def registry__update_api_deployment(
    project: str,
    location: str = ...,
    api: str = ...,
    deployment: str = ...,
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    allow_missing: Optional[bool] = Query(None, alias='allowMissing'),
    body: ApiDeployment = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}:deleteRevision',
    description=""" DeleteApiDeploymentRevision deletes a revision of a deployment. """,
    tags=['api_deployment_management'],
)
def registry__delete_api_deployment_revision(
    project: str, location: str = ..., api: str = ..., deployment: str = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}:listRevisions',
    description=""" ListApiDeploymentRevisions lists all revisions of a deployment.
 Revisions are returned in descending order of revision creation time. """,
    tags=['api_deployment_management'],
)
def registry__list_api_deployment_revisions(
    project: str,
    location: str = ...,
    api: str = ...,
    deployment: str = ...,
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}:rollback',
    description=""" RollbackApiDeployment sets the current revision to a specified prior
 revision. Note that this creates a new revision with a new revision ID. """,
    tags=['api_deployment_management'],
)
def registry__rollback_api_deployment(
    project: str,
    location: str = ...,
    api: str = ...,
    deployment: str = ...,
    body: RollbackApiDeploymentRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}:tagRevision',
    description=""" TagApiDeploymentRevision adds a tag to a specified revision of a
 deployment. """,
    tags=['api_deployment_management'],
)
def registry__tag_api_deployment_revision(
    project: str,
    location: str = ...,
    api: str = ...,
    deployment: str = ...,
    body: TagApiDeploymentRevisionRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/projects/{project}/locations/{location}/apis/{api}/versions',
    description=""" ListApiVersions returns matching versions. """,
    tags=['api_management', 'artifact_management'],
)
def registry__list_api_versions(
    project: str,
    location: str = ...,
    api: str = ...,
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    filter: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/projects/{project}/locations/{location}/apis/{api}/versions',
    description=""" CreateApiVersion creates a specified version. """,
    tags=['api_version_control'],
)
def registry__create_api_version(
    project: str,
    location: str = ...,
    api: str = ...,
    api_version_id: Optional[str] = Query(None, alias='apiVersionId'),
    body: ApiVersion = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}',
    description=""" DeleteApiVersion removes a specified version and all of the resources that
 it owns. """,
    tags=['api_management', 'api_deployment_management', 'api_version_control'],
)
def registry__delete_api_version(
    project: str,
    location: str = ...,
    api: str = ...,
    version: str = ...,
    force: Optional[bool] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}',
    description=""" GetApiVersion returns a specified version. """,
    tags=['api_management', 'api_version_control'],
)
def registry__get_api_version(
    project: str, location: str = ..., api: str = ..., version: str = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}',
    description=""" UpdateApiVersion can be used to modify a specified version. """,
    tags=['api_version_control', 'api_management'],
)
def registry__update_api_version(
    project: str,
    location: str = ...,
    api: str = ...,
    version: str = ...,
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    allow_missing: Optional[bool] = Query(None, alias='allowMissing'),
    body: ApiVersion = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs',
    description=""" ListApiSpecs returns matching specs. """,
    tags=['api_management'],
)
def registry__list_api_specs(
    project: str,
    location: str = ...,
    api: str = ...,
    version: str = ...,
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    filter: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs',
    description=""" CreateApiSpec creates a specified spec. """,
    tags=['api_specification_handling', 'api_management'],
)
def registry__create_api_spec(
    project: str,
    location: str = ...,
    api: str = ...,
    version: str = ...,
    api_spec_id: Optional[str] = Query(None, alias='apiSpecId'),
    body: ApiSpec = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}',
    description=""" DeleteApiSpec removes a specified spec, all revisions, and all child
 resources (e.g. artifacts). """,
    tags=[
        'api_management',
        'api_deployment_management',
        'api_version_control',
        'api_specification_handling',
    ],
)
def registry__delete_api_spec(
    project: str,
    location: str = ...,
    api: str = ...,
    version: str = ...,
    spec: str = ...,
    force: Optional[bool] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}',
    description=""" GetApiSpec returns a specified spec. """,
    tags=['api_management', 'api_version_control', 'api_specification_handling'],
)
def registry__get_api_spec(
    project: str,
    location: str = ...,
    api: str = ...,
    version: str = ...,
    spec: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}',
    description=""" UpdateApiSpec can be used to modify a specified spec. """,
    tags=[
        'api_management',
        'api_deployment_management',
        'api_version_control',
        'api_specification_handling',
    ],
)
def registry__update_api_spec(
    project: str,
    location: str = ...,
    api: str = ...,
    version: str = ...,
    spec: str = ...,
    update_mask: Optional[str] = Query(None, alias='updateMask'),
    allow_missing: Optional[bool] = Query(None, alias='allowMissing'),
    body: ApiSpec = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}:deleteRevision',
    description=""" DeleteApiSpecRevision deletes a revision of a spec. """,
    tags=[
        'api_management',
        'api_deployment_management',
        'api_version_control',
        'api_specification_handling',
    ],
)
def registry__delete_api_spec_revision(
    project: str,
    location: str = ...,
    api: str = ...,
    version: str = ...,
    spec: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}:getContents',
    description=""" GetApiSpecContents returns the contents of a specified spec.
 If specs are stored with GZip compression, the default behavior
 is to return the spec uncompressed (the mime_type response field
 indicates the exact format returned). """,
    tags=[
        'api_management',
        'api_deployment_management',
        'api_version_control',
        'api_specification_handling',
    ],
)
def registry__get_api_spec_contents(
    project: str,
    location: str = ...,
    api: str = ...,
    version: str = ...,
    spec: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}:listRevisions',
    description=""" ListApiSpecRevisions lists all revisions of a spec.
 Revisions are returned in descending order of revision creation time. """,
    tags=[
        'api_management',
        'api_deployment_management',
        'api_version_control',
        'api_specification_handling',
    ],
)
def registry__list_api_spec_revisions(
    project: str,
    location: str = ...,
    api: str = ...,
    version: str = ...,
    spec: str = ...,
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}:rollback',
    description=""" RollbackApiSpec sets the current revision to a specified prior revision.
 Note that this creates a new revision with a new revision ID. """,
    tags=[
        'api_deployment_management',
        'api_version_control',
        'api_specification_handling',
    ],
)
def registry__rollback_api_spec(
    project: str,
    location: str = ...,
    api: str = ...,
    version: str = ...,
    spec: str = ...,
    body: RollbackApiSpecRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}:tagRevision',
    description=""" TagApiSpecRevision adds a tag to a specified revision of a spec. """,
    tags=[
        'api_management',
        'api_deployment_management',
        'api_version_control',
        'api_specification_handling',
    ],
)
def registry__tag_api_spec_revision(
    project: str,
    location: str = ...,
    api: str = ...,
    version: str = ...,
    spec: str = ...,
    body: TagApiSpecRevisionRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/projects/{project}/locations/{location}/artifacts',
    description=""" ListArtifacts returns matching artifacts. """,
    tags=['artifact_management'],
)
def registry__list_artifacts(
    project: str,
    location: str = ...,
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    filter: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/projects/{project}/locations/{location}/artifacts',
    description=""" CreateArtifact creates a specified artifact. """,
    tags=['artifact_management', 'artifact_registry_management'],
)
def registry__create_artifact(
    project: str,
    location: str = ...,
    artifact_id: Optional[str] = Query(None, alias='artifactId'),
    body: Artifact = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/projects/{project}/locations/{location}/artifacts/{artifact}',
    description=""" DeleteArtifact removes a specified artifact. """,
    tags=['artifact_management', 'artifact_registry_management'],
)
def registry__delete_artifact(project: str, location: str = ..., artifact: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/projects/{project}/locations/{location}/artifacts/{artifact}',
    description=""" GetArtifact returns a specified artifact. """,
    tags=['artifact_management', 'artifact_registry_management'],
)
def registry__get_artifact(project: str, location: str = ..., artifact: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/projects/{project}/locations/{location}/artifacts/{artifact}',
    description=""" ReplaceArtifact can be used to replace a specified artifact. """,
    tags=['artifact_management', 'artifact_registry_management'],
)
def registry__replace_artifact(
    project: str, location: str = ..., artifact: str = ..., body: Artifact = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/projects/{project}/locations/{location}/artifacts/{artifact}:getContents',
    description=""" GetArtifactContents returns the contents of a specified artifact.
 If artifacts are stored with GZip compression, the default behavior
 is to return the artifact uncompressed (the mime_type response field
 indicates the exact format returned). """,
    tags=['artifact_management', 'artifact_registry_management'],
)
def registry__get_artifact_contents(
    project: str, location: str = ..., artifact: str = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
